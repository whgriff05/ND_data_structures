Introduction
Let’s say we have two people, Alice and Bob, who want to talk securely without any eavesdroppers. To achieve this, they agree on using a system to encrypt and decrypt their messages via public and private keys. If Alice wants to send a message to Bob, she can encrypt the message using Bob’s public key, and then send it to Bob. To read it, all Bob has to do is use his private key to decrypt the message. In this system, if the message is intercepted, it is indecipherable without that corresponding private key. 
	A system similar to the one described in the above example is known as the RSA cryptography algorithm, named for its creators Rivest, Shamir, and Adleman. It uses the scheme of each person having a public key and private key and using them to encrypt and decrypt messages respectively. One main use of the RSA algorithm is to securely send other encryption keys as RSA is a slow algorithm to decrypt, so it is used to only initialize communication between clients. One scenario where this is the case is the use of the Secure Shell, or SSH, protocol. Secure Shell is a security protocol that allows for people to remotely log into accounts on specific computers via another computer. When the user successfully logs in, the SSH protocol sends a code for symmetric encryption for following communication encrypted using the RSA algorithm. 
	Secure communication using RSA cryptography and the SSH protocol is important to discuss. These technologies are widely used in the professional world as many businesses hire employees to work with these protocols to perform maintenance and upkeep on their applications. As these technologies are very valuable for business use, many attacks have appeared against the RSA algorithm and the SSH protocol, so it is important to evaluate the severity of these attacks and whether these protocols have security proportional to usability of the algorithm.
To find out whether the RSA algorithm can facilitate secure SSH connections while still having practical encryption and decryption times, my research question is: What leads to active attacks compromising the usability of the Secure Shell protocol using the RSA algorithm?


Methodology
The active attacks used against the RSA algorithm and the Secure Shell protocol compromise its security through poor implementation, complex timing and error analysis, and the ease of discovering information. To prove this, tactics to prevent the active attacks used against the RSA algorithm and the SSH protocol are shown to be overly demanding. These shortcomings will then be weighed against the security benefits and protections that can be utilized to determine whether using SSH with the RSA algorithm is still practical and secure today.


Active Attacks Against the RSA Algorithm
The algorithm that RSA uses to encrypt and decrypt files was made to create key pairs that theoretically can be unbreakable. In the key pair generation process, two prime numbers are chosen to create the key pairs. Theoretically, if two large enough prime numbers are chosen, the cipher should be unbreakable. However, in practical use, the prime numbers chosen tend to be large enough for decent security but not large enough to make the time to decipher the message inefficient and, frankly, unusable. Since these theoretical perfect prime numbers aren’t chosen for the encryption to make the use of the algorithm practical for use, possible security flaws present themselves. In certain situations when information is encrypted using the RSA algorithm, the structure of the algorithm itself can present exploitable opportunities. 
The first active attack used against the RSA algorithm is known as a timing attack. It is a fairly basic attack in that all the attacker needs to know is the time it takes for a decryption or an encryption to take place. The example in “Twenty Years of Attacks on the RSA Cryptosystem” outlines a case in which a malicious attacker is tracking the amount of time a smartcard takes to sign multiple random messages. Using a calculation known as the repeated squaring algorithm, the times to sign a message can be deciphered into bits of one of the key pair’s exponents. This can work in tandem with the vulnerability of a low public exponent, and when some of the bits are generated, the entire key can be recovered as a result of that passive exploit.
To describe the next attack, a process known as padding needs to be understood. Padding is when a message contains less than the maximum bytes allotted to the message block. To fill the rest of the bytes, a padding value is added randomly to fill the message block. There are special bytes inserted to mark whether a message is padded and where the actual message starts. Daniel Bleichenbacher found a scenario in which a certain well-used padding scheme can be exploited to decrypt any intercepted message. Through processes, an “oracle” can be found that proves the use of that certain padding scheme and that can approximate what the ciphertext translates to when decrypted. This oracle can be found in a few ways. First, an impersonator can send encrypted messages to a server and check for returning error messages, showing that the message is not conforming to the padding scheme. An impersonator could also obtain an oracle from a scenario where different error messages are returned for an incorrect padding scheme and an unverified signature. Lastly, a version of the timing attack could be employed to calculate which signing key is used, and as such could obtain the oracle by applying the results of this attack to the error message method as well. This is an important attack to be conscious of as not all message strings are of equal length and as a result padding methods need to be utilized.
This oracle attack is important to mention, as it has been shown to appear in enterprise scenarios. Scientists have managed to find that specific vulnerability in large company platforms such as Facebook, Citrix, and Cisco. In their vulnerability report to Facebook engineers, they included a message signed with Facebook’s private signature, something only attainable usually with administrator access to Facebook’s servers and the corresponding private key. With access to Facebook’s private signature, malicious users could send out messages to other servers while being disguised as official Facebook servers.
The previously outlined oracle attack finds itself used in cases where the padding scheme on the RSA encryption was that of PKCS #1 v1.5, but in other versions, other attacks exist. PKCS #1 v2.0 offers solutions to counter the previously mentioned oracle attack; however, it lends itself to other vulnerabilities that leak information, allowing the use of oracles to still be relevant in this situation. In this scheme, a seed, a hash, a padding, and a secret are combined into an octet string. Multiple of these octet strings are then used with the message, randomized for their security. In this case, a seed is a number, such as the time, used to introduce entropy, or a sense of randomness, into the system. A secret is a phrase, described as a session key, which is kept secret and is a sign by the administrator of the server connected to that the encryption was performed correctly. 
“A Chosen Ciphertext Attack on RSA Optimal Asymmetric Encryption Padding (OAEP) as Standardized in PKCS #1 V2.0” outlines specific scenarios where servers are vulnerable to this attack. This attack, known as Manger’s attack, depends on a failure in the octet creation from the integrity check, where the secret and seed are revealed by the server to ensure the encryption was successful by comparing it to another hash, and if the error messages between the octet creation step and the integrity check step are not the same, attackers can sense the vulnerability and then perform the attack. Basic items such as the spellings of the error messages or the details outlined in the server log files need to be observed and made consistent. Timing is also a large concern with this attack, as integrity checks take longer than the octet creation step. In the integrity check creation step, the octet hash is compared to a local hash from parameters, and to get data on times, attackers can create a sufficiently large or complicated enough parameter to submit which will end up used in the integrity check. Lastly, as this probing attack relies on errors, it is significantly harder to counter as errors still need to be descriptive and handled effectively for normal users to make efficient use of this protocol. It is tough to obfuscate errors enough to take away these attack vectors from potential malicious users while maintaining the balance of being helpful to end users. 
Measures are taken to mitigate these attacks, but since they rely on the will and effort of the attacker and a little random chance for the opportunity to prevent itself, they cannot be fully protected from. For this reason, it is necessary to securely store these keys. Another evaluation that is considered when dealing with attacks is whether the encryption and decryption time is practical for use as well as secure. Corners are cut to slightly improve this efficiency of the RSA algorithm and these cut corners can and have already led to more attacks. User trust is also an important consideration, specifically mentioned in the last active attack described, in that the user assumes all communications are secure and there is little to no possibility for attack. Oracle attacks also have to be weighed, such as the attack against PKCS #1 v1.5 or Manger’s attack, as they are easy for attackers to implement, and they rely on the interpretation of error messages, which need to be descriptive enough to help end users with actual errors. All of these considerations need to be taken into account to accurately evaluate the true security of the RSA algorithm.

Exploits Present in the SSH Protocol 
In conjunction with evaluating the effectiveness of the security of the RSA algorithm, the Secure Shell Protocol’s defense must also be gauged. Secure Shell, commonly shortened to “SSH,” is a protocol that allows for users to access files and programs on computers remotely via a second computer. As it says in the name, it was built for secure access, so many safety components are built in. However, no secure system is perfect, and attacks exist against this protocol. In addition to the vulnerabilities present in the RSA algorithm, attacks exist within the SSH protocol that can allow for malicious users to gain unwanted access to private information.
	The first main vulnerability present in the SSH protocol is known as “de-anonymization,” or where a SSH user can learn all of a client’s public keys, and with this, can gather information about who the client belongs to. This attack works by a server denying every public key offered by the client while simultaneously storing all keys that are sent. Multiple servers performing this can be used to find common users, and these public keys can be used in later vulnerabilities to perform more malicious acts. As SSH is a remote tool, malicious users don’t always know who their attacks are targeting, so this exploit can be used to identify users that the attacker is targeting. Next, now that the malicious user has all of the public keys, they can be checked against a database containing the public keys and their corresponding public information, for example, a username. The example outlined in “Practical Privacy-Preserving Authentication for SSH” uses a GitHub username-to-public-key database to learn the username associated with the public key. This attack is a first step for other attacks against SSH as it identifies the client who the attack is performed on.
The next attack that can be used against the SSH protocol is a technique called “user-probing.” When a malicious client user-probes a server, they check if a public key is authorized on that server for a specific username. This is done by sending public keys and their corresponding username to that server and seeing whether a rejection or acceptance message is returned. This allows the malicious user to learn what users have authorization for a specific server. This attack can open up opportunities for the malicious user. First, they can learn what accounts are present on a server, which can act as another means of de-anonymization. Second, they can use statistics on usage patterns per user to pick a certain target. This attack has been present since May 2002; however, the vulnerability has not been fixed yet, so it is safe to assume this technique will continue to work for the future. Lastly, the attack is especially good at targeting clients who use the same username for different accounts, as when this attack is performed on multiple databases, common users can be found. User-probing is an attack that can be used to highlight specific targets and choose which one to target.
Attacks against the Secure Shell protocol are also important to consider when evaluating the total security of the system. While they aren’t completely about assuming the identity of another user or directly taking their data, these attacks can be utilized to locate other possible attack vectors and are more used for selecting a target instead of attacking the target directly. Attacks like de-anonymization and user-probing allow for attackers to determine which users have access to servers, which can help the malicious users choose which target to attack. All of these attacks must be evaluated when considering the total security of the Secure Shell protocol. 


Combined Analysis of Vulnerabilities
The Secure Shell protocol has many steps in its process, from the user authentication on initial connection made secure by the RSA algorithm to ongoing communication made possible using the TCP framework. These many steps introduce many possible attack vectors that can be exploited as with each new method or dependency added, those corresponding vulnerabilities come as well. These vulnerabilities can even be used together for more chances of a successful attack. Vulnerabilities present on either side (RSA or SSH) can compromise a user’s encryption ability and the security of the system as a whole. 
	First, the RSA user authentication step is integral to the function of SSH, as it securely sets up the communication protocol used for the rest of the session, so if the RSA algorithm is attacked in that step, the entire communication could be compromised. For example, malicious users could track encryption and decryption times for a timing attack, or they could test the server for basic flaws like a low exponent or a common modulus. Then, with this knowledge, they could try to factor and determine the victim’s private key. With the private key in their possession, they could imitate the victim and compromise their account. 
	Second, the most vulnerable step in the entire SSH communication is the user authentication. Since it depends on the RSA algorithm and the SSH setup protocol, the most vulnerabilities exist at this point in time. Most use of the SSH protocol deals with the time after user authentication, and as a result more work is put into making the later communication as stable as possible, even though less vulnerabilities are present at that point in time. 
	There is also no standard for how SSH is implemented on servers. The most popular and well-used SSH program, OpenSSH, allows users and companies to change the requirements as they want. While this could be seen as a benefit, as attackers don’t always know how defended a server is, this is also seen as a disadvantage as there is no standard of security or minimum defense required for its use. As a result, there is the chance that exploits could be opened up as some less knowledgeable systems operators might choose to prioritize performance over security not understanding the implications of their actions. For example, a smaller company might choose to lower their prime number size to allow for faster connections if many people need to connect to their servers at once. This would be a situation where an exploit is opened up as a result, as lower exponents can lead to easier factoring and recovery of private keys. 
	Lastly, once one account is cracked, other accounts are in danger of being compromised as well. For example, if a victim manages to connect to a honeypot (a server that is designed to be connected to instead of the original intended server), malicious users can use the victim’s information to gather all of their public keys. From this, the malicious users can find ways to access the victim’s other accounts on other servers.


Counterarguments
Most of this essay has focused on the vulnerabilities and shortcomings of the RSA algorithm and the SSH protocol. However, it is also important to include the many security features in these tools in the complete evaluation of security. Both of these technologies were made specifically for secure use, so while vulnerabilities can be present, many defenses have also been put in place. The RSA algorithm and the SSH protocol have been engineered to be very secure in their use, so many possible vulnerabilities have been eliminated or mitigated.
	The RSA algorithm has many security features as it was built specifically to be a means of keeping data private. First, RSA can be considered theoretically perfectly secure as if infinitely large prime factors are chosen, the modulus would be impossible to factor by modern computing standards. While practically this would never be attainable, this feature does show that as larger prime factors are chosen, the moduli are harder to factor and therefore a more secure encryption has been performed. Second, the RSA encryption is known as a “one-way trapdoor function.” Messages are encrypted using a public key, and these encrypted messages can only be decrypted using a private key. There is no inverse to the encryption except for when one possesses the private key, which acts as the “trapdoor” for the function. This is an integral security feature as the only way to recover encrypted material is with that corresponding private key, and when this cryptosystem is attacked, there is only one possible means of compromising secure information which is that private key. 
	Functioning as a secure means of remote access, Secure Shell also contains many security features. First, communication for SSH is initiated by the client. Users always are the ones connecting to servers remotely; the servers never remotely connect to the client on their own. This is a vital security measure as it means that no complete attacks can be made if the protocol is not being used. No background protection has to be put into place against servers automatically connecting as it doesn’t happen. Next, for an attack to happen, it must happen at the initial connection as subsequent connections have already established the client-server connection. SSH provides a great defense to this by not allowing observers to see whether a connection is initial or subsequent. This forces the attacker to try all connections with the possibility of their discovery or forfeit the attack. 
Along with these passive measures provided, Secure Shell works actively for secure communication. SSH works against active hijacking, where a malicious user can inject their own messages into a connection. SSH’s prevention is simple: if it detects any modification in the session, it immediately closes the connection. SSH also prevents connections to imposter servers using the IP addresses of the intended servers by cryptographically verifying their key against a local list. If the server’s given key doesn’t match, the user is warned and can choose to close the connection. This also prevents “man-in-the-middle” attacks for the reason above but also because it will be detected in subsequent communications by the user. A specific signature is given to the connection, and unless the malicious server acting between the victim and their intended connection has access to their private key, they will have to give another key pair and receive a different signature. If SSH detects a difference in signatures, a warning will be raised and the connection will be closed. These are very helpful security measures as before anything important can be stolen or destroyed, the connection is closed meaning the victim or the malicious user can no longer interact with what was being remotely accessed.
All of these helpful security features built into these tools are integral to keeping remote communication defended. For example, choosing larger numbers in the RSA scheme can be an easy way of adding security for the price of decryption time. Also, its asymmetric scheme allows for the one-way encryption so only one way exists for decryption. In addition, the attackers are forced to be ready at immediate connection time and guess at which connections are new connections. Lastly, there are many built-in active measures to prevent interference in communication. However, not all of these countermeasures prevent attacks. By narrowing down the possibilities for attack, these countermeasures have forced attackers to focus on one specific time for attack. With this constraint, they can narrow down more resources to target that specific time and area to attempt to gain access. Also, the “trapdoor” in the RSA algorithm allows for malicious users to gain a skeleton key for all future messages they intercept for that one victim if they successfully obtain the victim’s private key. In conclusion, while security features were built into the RSA algorithm and the Secure Shell protocol, they only mitigate attacks and provide more narrow attack vectors for malicious users.


Conclusion
Through poor implementation, timing and error analysis, and the ease of access to information, active attacks against the RSA algorithm and the Secure Shell protocol compromise its security. While both the RSA algorithm and the SSH protocol were built for security and have many inherent defenses, the broad array of exploits and attacks to be used against it make using these tools securely impractical for real-world use. To safeguard the RSA algorithm, much higher prime factors would need to be chosen for key pairs as all attacks depend on factoring, and since the magnitude of the number is proportional to decryption time, the algorithm would become impractical to use due to the calculation times. To protect the SSH protocol, a major refactoring would need to take place because many of the exploits that are used against SSH are due to how it performs its tasks. A rewrite of SSH would then lead to updates being necessary everywhere it is used and potentially new exploits that would then need to be worked against. Considering all this, RSA and SSH contain vulnerabilities and attacks that are unproportional to their practicality as a system. 
	Some new understandings were also made clear in this research process. First, for being prominent, widely-used tools, the RSA algorithm and the Secure Shell protocol have many vulnerabilities. While some of these exploits seem unlikely to happen, it is probable for some malicious users to be using some of the less preventable exploits, like setting up honeypot servers or timing RSA key encryption and decryption times. Also, there is such an importance placed on the initial connection between client and server. Without the successful key sharing and the initial protocol set-up, the connection is terminated and the user will have to try again. In addition to the importance, it is also the step with the only chance of attack, as future connections are completely encrypted and if messages are tampered the connection is shut down. 
	While the Secure Shell protocol and the RSA algorithm used for its authentication are engineered to be secure with appropriate defenses against attacks, both technologies contain many vulnerabilities and possible attacks to be used against them. Securing either tool more would cause it to become harder to use in real-life situations, so security is sacrificed when these tools are implemented for usability. However, the vulnerabilities present in both the Secure Shell protocol and the RSA algorithm along with the attacks to be used against them provide a threat unproportional to the practicality of use. 
